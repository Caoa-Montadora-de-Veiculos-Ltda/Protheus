#INCLUDE "TOTVS.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "RESTFUL.CH"

/*/{Protheus.doc} ZRESTESL
Serviço de integração Consulta Valor do Modelo
@author 	Victor Gisoldi Matos 
@since 		01/10/2024
@version 	1.0
@param		nao utilizado
@type 		User Function
@client   	CAOA
@return   	_aMsg - Array com retorno Json código e ocorrencia
@project 	API Consulta Valor do Modelo
			https://tdn.totvs.com/display/tec/DecodeUTF8
			https://jsonformatter.curiousconcept.com/  VERIFICAR SE JSON ESTA CORRETO
			https://jsonlint.com/?code=   //VALIDAR JSON
            https://jsoneditoronline.org/#left=local.sowavu  //estrutura do json
/*/
User Function ZRESTVLR( _oJson , _cEmpFil , _cResp )

Local _aMsg As Array

Private _aRetMsg As Array
Private _aMsgRet As Array

Default _cEmpFil := ""
Default _cResp   := ""

Begin Sequence
	Conout( "INICIADO FUNCIONALIDADE ZRESTVLR em " + DtoC(Date()) + " as " + Time() )
	_aMsg 	 := {}
	_aRetMsg := ZRESTVLRMsg()   //Carregar tabela com erros
	_aMsgRet := {}				//carregar msg de errp

	// Processa o Json
	If ZRESTVLRPR( @_oJson , _cEmpFil , _cResp )
		_aMsg := _aMsgRet // Recebe erro do processamento
	EndIf
End Sequence

IF Len( _aMsg ) == 0	//Prevensão forçar o envia da mensagem para o REST

	_aMsg := U_ZSetMsgJson()

EndIf

Conout( "FINALIZADO FUNCIONALIDADE ZRESTESL em " + DtoC( Date() ) + " as " + Time() )

Return _aMsg

/*/{Protheus.doc} ZRESTVLRPR
	Recebe Json cliente GET 
	@author 	Victor Gisoldi Matos
	@since 		18/09/2024
	@version 	1.0
	@param 		oJson
	@type 		function
	@ Obs		Os paremetros de token, empresa e filial serão enviados no cabeçalho reader Json
/*/
Static Function ZRESTVLRPR( _oJson , _cEmpFil , _cResp )

Local _cEmpresa	As Character
Local _cFilAtu	As Character
Local _lRet		As Logical
Local _nPos		As numeric

Begin Sequence
	_cEmpresa	:= ""
	_cFilAtu	:= ""
	_lRet		:= .F.
	_nPos 		:= At( "," , _cEmpFil )

	If _nPos <= 0 
		U_ZRETMsgJson( "empresa" , "nao informada tag empresa" )
        Break
    EndIf
	
	_cEmpresa := SubsTr( _cEmpFil , 1 , _nPos - 1 )
	_cFilAtu  := SubsTr( _cEmpFil , _nPos + 1 )

	If Empty( _cEmpresa )
		U_ZRETMsgJson( "empresa" , "nao informada tag empresa" )
        Break
	Endif
	
	If Empty( _cFilAtu )
		U_ZRETMsgJson( "filial" , "nao informada a filial na tag empresa" )
        Break
	Endif
	
	//Verifica a existencia empresa, para não ficar retornando erro 5, valida se a tabela esta abertar
	If Select("SM0") > 0
		SM0->(DbSetOrder(1))  // M0_CODIGO + M0_CODFIL
		If !SM0->(DbSeek(_cEmpresa+_cFilAtu))
			U_ZRETMsgJson( "empresa" , "Dados da empresa inconsistentes" )
        	Break
		Endif
	Endif
    
	//Tratar abertura da empresa conforme enviado no parametro
	If cEmpAnt <> _cEmpresa .or. cFilAnt <> _cFilAtu
    	RpcClearEnv() 
    	RPCSetType(3) 
    	If !RpcSetEnv( _cEmpresa , _cFilAtu , , , , GetEnvServer() , { } )
			U_ZRETMsgJson( "ambiente" , "Nao foi possivel acessar ambiente" )
        	Break
		Endif
	EndIf
	
	//Verificar se existe cadastro fornecedor , o Genérico não sendo 
	SA2->(DbSetOrder(3))  //FILIAL + CGC
	
	// Valida os dados do oJson
	If !SA2->(DbSeek(FWxFilial("SA2")+_cResp))  //.And. _cResp <> STRZero(0,8)  //Deixar passar com tudo zero para validaçoes
		U_ZRETMsgJson( "responsavel" , "Nao Autorizado, Falta Cadastro" )
        Break
	Endif 	
	
	If !ValidOJson( @_oJson , )
		Break
	EndIf
	
	//Realiza a consulta
	_lRet := ZRESTVLRCO( _oJson , _cEmpresa , _cFilAtu , _cResp )
End Sequence

Return _lRet

/*/{Protheus.doc} ZRESTVLRCO
	Receber dados do oJson e Consultar Saldo
	@author Victor Gisoldi Matos
	@since 18/09/2024
	@version 1.0
	@param 
	@type function
/*/
Static Function ZRESTVLRCO( _oJson , _cEmpresa , _cFilAtu , _cResp )

Local _cAliasPesq	As Character
Local _cModelo		As Character
Local _cSegmento	As Character
Local _cAnoFab		As Character
Local _cAnoMod		As Character
Local _cFabMod		As Character
Local _nValTab		As Numeric
Local _nValIcm		As Numeric
Local _lRet			As Logical

Begin Sequence
	_cAliasPesq	:= GetNextAlias()
	_cModelo	:= AllTrim(_oJson:GetJsonText("cdmodvei"))  
	_cSegmento	:= AllTrim(_oJson:GetJsonText("cdsegmod"))  
	_cAnoFab	:= AllTrim(_oJson:GetJsonText("anofabricacao"))
	_cAnoMod	:= AllTrim(_oJson:GetJsonText("anomodelo"))
	_cFabMod	:= ''
	_nValTab	:= 0
	_nValIcm	:= 0
	_lRet		:= .T.

	//Função para retorno de códigos, verificar se estas informações estão fornecidas corretamente
	If !ZRESTValida( _oJson , _cModelo , _cSegmento , _cAnoFab, _cAnoMod )
		_lRet := .F.
		Break
	Endif

	If Select( (_cAliasPesq) ) > 0
		(_cAliasPesq)->(DbCloseArea())
	EndIf

	//Concatena Ano de Fabricação + Ano Modelo
	_cFabMod := _cAnoFab + _cAnoMod 
			
	/*	Condições para consultar saldo:
		VVP_MODVEI = _cModelo
		VVP_SEGMOD = _cSegmento
		VVP_FABMOD = _cFabMod
	*/

	cQuery := "SELECT VVP.R_E_C_N_O_ NREGVVP, "
	cQuery += "		  VVP.VVP_VALTAB AS VALTAB, "
	cQuery += "		  VVP.VVP_BASEST AS BASEST"
	cQuery += "FROM " + RetSQLName('VVP') + " VVP "
	cQuery += "WHERE VVP.D_E_L_E_T_ = '' AND "
	cQuery += "      VVP.VVP_FILIAL = '" + FwXFilial("VVP") + "' AND "
	cQuery += "		 VVP.VVP_MODVEI = '" + _cModelo + "' AND "
	cQuery += "		 VVP.VVP_SEGMOD = '" + _cSegmento + "' AND "
	cQuery += "		 VVP.VVP_FABMOD = '" + _cFabMod + "' AND "
	cQuery += "		 VVP.VVP_DATPRC = ( SELECT MAX(VVPB.VVP_DATPRC) "
	cQuery += "							FROM " + RetSQLName('VVP') + " VVPB "
	cQuery += "							WHERE VVPB.D_E_L_E_T_ = '' AND "
	cQuery += " 							  VVPB.VVP_FILIAL = VVP.VVP_FILIAL AND "
	cQuery += "								  VVPB.VVP_CODMAR = VVP.VVP_CODMAR AND "
	cQuery += "								  VVPB.VVP_MODVEI = VVP.VVP_MODVEI AND "
	cQuery += "								  VVPB.VVP_SEGMOD = VVP.VVP_SEGMOD AND "
	cQuery += "								  VVPB.VVP_FABMOD = VVP.VVP_FABMOD )"

	cQuery := ChangeQuery(cQuery)

	// Executa a consulta.
	DbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), _cAliasPesq, .T., .T. )

	DbSelectArea((_cAliasPesq))

	If (_cAliasPesq)->(!Eof())
		//VVP->((_cAliasPesq)->NREGVVP)
		_nValTab := (_cAliasPesq)->VALTAB
		_nValIcm := (_cAliasPesq)->BASEST
		ZRETJson( "ok" , "cdmodvei"	  	 , _cModelo   )
		ZRETJson( "ok" , "cdsegmod"	  	 , _cSegmento )
		ZRETJson( "ok" , "anofabricacao" , _cAnoFab   )
		ZRETJson( "ok" , "anomodelo"	 , _cAnoMod   )
		ZRETJson( "ok" , "valortabela"	 , _nValTab	  )
		ZRETJson( "ok" , "baseicms"	 	 , _nValIcm	  )
	EndIf

	(_cAliasPesq)->(DbCloseArea())
End Sequence 

return _lRet

/*/{Protheus.doc} ZRESTValida
	Valida os dados redebidos do Json
	@author Victor Gisoldi Matos
	@since 18/09/2024
	@version 1.0
	@param 
	@type function
/*/
Static Function ZRESTValida( _oJson , _cModelo , _cSegmento , _cAnoFab, _cAnoMod )

Local _lRet As Logical

Default _cModelo	:= ""
Default _cSegmento	:= ""
Default _cAnoFab	:= ""
Default _cAnoMod	:= ""

Begin Sequence
	_lRet := .T.

	//Valida o código do modelo
	If Empty(_cModelo) .OR. len(_cModelo) > 30 .OR. !VldMod(_cModelo)
		U_ZRETMsgJson("cdmodvei","Código do modelo vazio, ou inválido: " + _cModelo )
		_lRet := .F.
		Break
 	Endif

	//Valida o segmento
	If Empty(_cSegmento) .OR. len(_cSegmento) > 15 .OR. !VldSeg(_cSegmento)
		U_ZRETMsgJson("cdsegmod","Código do Segmento vazio, ou inválido: " + _cSegmento )
		_lRet := .F.
		Break
 	Endif

	//Valida o Ano de Fabricacao
	If Empty(_cAnoFab) .OR. len(_cAnoFab) <> 4 .OR. !IsNumeric(_cAnoFab)
		U_ZRETMsgJson("anofabricacao","Ano de Fabricacao vazio, ou inválido: " + _cAnoFab )
		_lRet := .F.
		Break
 	Endif

	//Valida o Ano do Modelo
	If Empty(_cAnoMod) .OR. len(_cAnoMod) <> 4 .OR. !IsNumeric(_cAnoMod)
		U_ZRETMsgJson("anomodelo","Ano do Modelo vazio, ou inválido: " + _cAnoMod )
		_lRet := .F.
		Break
 	Endif
End Sequence 

Return _lRet

/*/{Protheus.doc} ValidOJson
Valida os Itens do oJson
@author Victor Gisoldi Matos
@since 18/09/2024
@version 1.0
@param nCode, numeric, descricao
@param cMsg, characters, descricao
@type function
/*/
Static Function ValidOJson( _oJson , _cTipo )

Local _lRet		As Logical
Local _aMens 	As Array

//Tem a função de validar os itens obrigatórios neste caso o vabeçalho ZWSRFUN.PRW
_aMens	:= U_ZVLDOBRJ( _oJson , _aRetMsg , /*_lItem*/ , /*_lTodos*/ )
_lRet	:= .T.

If Len(_aMens) > 0
  	_aMsgRet 	:= _aMens
	_lRet		:= .F.	
Endif

Return _lRet

/*/{Protheus.doc} ZRESTVLRMsg
//Carrega Numero do Erro para retorno
@author Victor Gisoldi Matos
@since 18/09/2024
@version 1.0
@param _aMsg , array , descrição
@type function

Layout que será recebido da Autoware:
{
   "cdmodvei":"T17W5L4FP",
   "cdsegmod":"C755TRYBLP",
   "anofabricacao":"2024",
   "anomodelo":"2025"
}
/*/
Static Function ZRESTVLRMsg()

Local _aRet As Array

Begin Sequence
	_aRet := {}

	//			{ Nr Ret , Tags Json	   , Item ,	Obrig ,	Descrição	
	Aadd(_aRet, { 100    , "ok"			   , .F.  , .F.	  , "Processo realizado com sucesso"	 } )

	Aadd(_aRet, { 300	 , "empresa"	   , .F.  , .F.   , "Empresa nao informada"				 } )
	Aadd(_aRet, { 301	 , "filial"		   , .F.  , .F.   , "Filial nao informada"				 } )
	Aadd(_aRet, { 302	 , "token"		   , .F.  , .F.   , "Token Invalido"					 } )
	Aadd(_aRet, { 303	 , "ambiente"	   , .F.  , .F.   , "Nao foi possivel acessar ambiente"  } )
	Aadd(_aRet, { 304	 , "responsavel"   , .F.  , .F.   , "Não Autorizado"					 } )

	Aadd(_aRet, { 400	 , "cdmodvei"	   , .F.  , .T.   , "Modelo do veículo com problemas"	 } )
	Aadd(_aRet, { 401	 , "cdsegmod"	   , .F.  , .T.   , "Segmento do veículo com problemas"  } )
	Aadd(_aRet, { 402	 , "anofabricacao" , .F.  , .T.   , "Ano de Fabricacao com problemas"	 } )
	Aadd(_aRet, { 403	 , "anomodelo" 	   , .F.  , .T.   , "Ano de Fabricacao com problemas"	 } )

//	Aadd(_aRet, { 600	 , "erropad"       , .F.  , .T.   , "nao foi possivel atualizar Cliente" } )
End Sequence

Return _aRet

/*/{Protheus.doc} ZRETJson
//Retorna Numero do Erro 
@author Victor Gisoldi Matos
@since 01/10/2024
@version undefined
@param _aMsg, array, descrição
@type function
/*/
Static Function ZRETJson(_cRefMsg, _cMsgRet, _cVar)

Local _nRet := 999
Local _nPos

Default _cMsgRet := ""

Begin Sequence
	If Type("_aRetMsg") <> "A"
		Private _aRetMsg := {}
	EndIf
	If Type("_aMsgRet") <> "A"
		Private _aMsgRet := {}
	EndIf

  	_nPos := Ascan(_aRetMsg,{|x| x[2] == _cRefMsg})
	If _nPos > 0 
		_nRet := _aRetMsg[_nPos,1]
	EndIf	
	If Empty(_cMsgRet) .and. Len(_aRetMsg[_nPos]) >= 5 .and. ValType(_aRetMsg[_nPos,5]) == "C"
		_cMsgRet := _aRetMsg[_nPos,5]+" !"
	Endif	
	Aadd(_aMsgRet, {_nRet,_cMsgRet, _cVar})
End Sequence

Return _nRet

/*/{Protheus.doc} VldMod
	Valida de o codigo de modelo recebido no Json é valido
	@type  Function
	@author Victor Matos
	@since 30/09/2024
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function VldMod(_cModelo)

Local _cAlias	As Character
Local lRet		As Logical
Local cMod		As Character
Local cQuery	AS Character

_cAlias	:= GetNextAlias()
lRet 	:= .T.
cMod 	:= ''
cQuery 	:= ''

If Select( (_cAlias) ) > 0
	(_cAlias)->(DbCloseArea())
EndIf

cQuery := " SELECT VV1.VV1_MODVEI AS MODELO "
cQuery += " FROM " + RetSQLName('VV1') + " VV1 "
cQuery += " WHERE VV1.D_E_L_E_T_ = '' AND "
cQuery += "		  VV1.VV1_MODVEI = '" + _cModelo + "' "
cQuery += " GROUP BY VV1.VV1_MODVEI"

cQuery := ChangeQuery(cQuery)

// Executa a consulta.
DbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), _cAlias, .T., .T. )

DbSelectArea((_cAlias))

cMod := (_cAlias)->MODELO

If Empty( cMod )
	lRet := .F.
EndIf

(_cAlias)->(DbCloseArea())

Return lRet

/*/{Protheus.doc} VldSeg
	Valida de o segmento recebido no json é válido
	@type  Function
	@author Victor Gisoldi Matos
	@since 30/09/2024
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function VldSeg(_cSegmento)

Local _cAlias	As Character
Local lRet		As Logical
Local cSeg		As Character
Local cQuery	As Character

_cAlias	:= GetNextAlias()
lRet 	:= .T.
cSeg 	:= ''
cQuery	:= ''

If Select( (_cAlias) ) > 0
	(_cAlias)->(DbCloseArea())
EndIf

cQuery := " SELECT VV1.VV1_SEGMOD AS SEGMENTO "
cQuery += " FROM " + RetSQLName('VV1') + " VV1 "
cQuery += " WHERE VV1.D_E_L_E_T_ = '' AND "
cQuery += "		  VV1.VV1_SEGMOD = '" + _cSegmento + "' "
cQuery += " GROUP BY VV1.VV1_SEGMOD"

cQuery := ChangeQuery(cQuery)

// Executa a consulta.
DbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), _cAlias, .T., .T. )

DbSelectArea((_cAlias))

cSeg := (_cAlias)->SEGMENTO

If Empty( cSeg )
	lRet := .F.
EndIf

(_cAlias)->(DbCloseArea())

Return lRet
