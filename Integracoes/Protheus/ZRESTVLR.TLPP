#INCLUDE "TOTVS.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "RESTFUL.CH"

/*/{Protheus.doc} ZRESTESL
Serviço de integração Consulta Valor do Modelo
@author 	Victor Gisoldi Matos 
@since 		01/10/2024
@version 	1.0
@param		nao utilizado
@type 		User Function
@client   	CAOA
@return   	_aMsg - Array com retorno Json código e ocorrencia
@project 	API Consulta Valor do Modelo
			https://tdn.totvs.com/display/tec/DecodeUTF8
			https://jsonformatter.curiousconcept.com/  VERIFICAR SE JSON ESTA CORRETO
			https://jsonlint.com/?code=   //VALIDAR JSON
            https://jsoneditoronline.org/#left=local.sowavu  //estrutura do json
/*/
User Function ZRESTVLR( _oJson , _cEmpFil , _cResp )
Local _aMsg :=	{}		As Array
Local _oJsonRet			As Object

Private _aRetMsg As Array
Private _aMsgRet As Array

Default _cEmpFil := ""
Default _cResp   := ""

Begin Sequence
	Conout( "INICIADO FUNCIONALIDADE ZRESTVLR em " + DtoC(Date()) + " as " + Time() )
	_aRetMsg := ZRESTVLRMsg()   //Carregar tabela com erros
	_aMsgRet := {}				//carregar msg de errp

	// Processa o Json
	If  ZRESTVLRPR( @_oJson ,  _cEmpFil , _cResp )
		//Realiza a consulta
		If 	ZRESTVLRCO( _oJson , @_oJsonRet )
			U_ZRETMsgJson("ok","" , _oJsonRet )
		Else
			_aMsg := U_ZSetMsgJson()
		Endif 
	Endif 
End Sequence
If Len( _aMsg ) == 0	//Prevensão forçar o envia da mensagem para o REST
	_aMsg := U_ZSetMsgJson()
EndIf

Conout( "FINALIZADO FUNCIONALIDADE ZRESTESL em " + DtoC( Date() ) + " as " + Time() )

Return _aMsg

/*/{Protheus.doc} ZRESTVLRPR
	Recebe Json cliente GET 
	@author 	Victor Gisoldi Matos
	@since 		18/09/2024
	@version 	1.0
	@param 		oJson
	@type 		function
	@ Obs		Os paremetros de token, empresa e filial serão enviados no cabeçalho reader Json
/*/
Static Function ZRESTVLRPR( _oJson , _cEmpFil , _cResp )
Local _cEmpresa	As Character
Local _cFilAtu	As Character
Local _lRet		As Logical
Local _nPos		As numeric

Begin Sequence
	_cEmpresa	:= ""
	_cFilAtu	:= ""
	_lRet		:= .F.
	_nPos 		:= At( "," , _cEmpFil )

	If _nPos <= 0 
		U_ZRETMsgJson( "empresa" , "nao informada tag empresa" )
        Break
    EndIf
	
	_cEmpresa := SubsTr( _cEmpFil , 1 , _nPos - 1 )
	_cFilAtu  := SubsTr( _cEmpFil , _nPos + 1 )

	If Empty( _cEmpresa )
		U_ZRETMsgJson( "empresa" , "nao informada tag empresa" )
        Break
	Endif
	
	If Empty( _cFilAtu )
		U_ZRETMsgJson( "filial" , "nao informada a filial na tag empresa" )
        Break
	Endif
	//Verifica a existencia empresa, para não ficar retornando erro 5, valida se a tabela esta abertar
	If Select("SM0") > 0
		SM0->(DbSetOrder(1))  // M0_CODIGO + M0_CODFIL
		If !SM0->(DbSeek(_cEmpresa+_cFilAtu))
			U_ZRETMsgJson( "empresa" , "Dados da empresa inconsistentes" )
        	Break
		Endif
	Endif
	//Tratar abertura da empresa conforme enviado no parametro
	If cEmpAnt <> _cEmpresa .or. cFilAnt <> _cFilAtu
    	RpcClearEnv() 
    	RPCSetType(3) 
    	If !RpcSetEnv( _cEmpresa , _cFilAtu , , , , GetEnvServer() , { } )
			U_ZRETMsgJson( "ambiente" , "Nao foi possivel acessar ambiente" )
        	Break
		Endif
	EndIf
	//Verificar se existe cadastro fornecedor , o Genérico não sendo 
	SA2->(DbSetOrder(3))  //FILIAL + CGC
	// Valida os dados do oJson
	If !SA2->(DbSeek(FWxFilial("SA2")+_cResp))  //.And. _cResp <> STRZero(0,8)  //Deixar passar com tudo zero para validaçoes
		U_ZRETMsgJson( "responsavel" , "Nao Autorizado, Falta Cadastro" )
        Break
	Endif 	
	_lRet := ValidOJson( @_oJson , )

End Sequence
Return _lRet

/*/{Protheus.doc} ZRESTVLRCO
	Receber dados do oJson e Consultar Saldo
	@author Victor Gisoldi Matos
	@since 18/09/2024
	@version 1.0
	@param 
	@type function
/*/
Static Function ZRESTVLRCO( _oJson , _oJsonRet )
Local _cAliasPesq	As Character
Local _cModelo		As Character
Local _cSegmento	As Character
Local _cAnoFab		As Character
Local _cAnoMod		As Character
Local _cFabMod		As Character
Local _nValTab		As Numeric
Local _nValIcm		As Numeric
Local _lRet			As Logical

Begin Sequence
	_cAliasPesq	:= GetNextAlias()
	_cModelo	:= AllTrim(_oJson:GetJsonText("cdmodvei"))  
	_cSegmento	:= AllTrim(_oJson:GetJsonText("cdsegmod"))  
	_cAnoFab	:= AllTrim(_oJson:GetJsonText("anofabricacao"))
	_cAnoMod	:= AllTrim(_oJson:GetJsonText("anomodelo"))
	_cFabMod	:= ''
	_nValTab	:= 0
	_nValIcm	:= 0
	_lRet		:= .F.

	//Função para retorno de códigos, verificar se estas informações estão fornecidas corretamente
	If !ZRESTValida( _oJson , _cModelo , _cSegmento , _cAnoFab, _cAnoMod )
		_lRet := .F.
		Break
	Endif

	If Select( (_cAliasPesq) ) > 0
		(_cAliasPesq)->(DbCloseArea())
	EndIf

	//Concatena Ano de Fabricação + Ano Modelo
	_cFabMod := _cAnoFab + _cAnoMod 
			
	/*	Condições para consultar saldo:
		VVP_MODVEI = _cModelo
		VVP_SEGMOD = _cSegmento
		VVP_FABMOD = _cFabMod
	*/
	BeginSql Alias _cAliasPesq
		SELECT VVP.R_E_C_N_O_ NREGVVP
				, VVP.VVP_VALTAB AS VALTAB
				, VVP.VVP_BASEST AS BASEST
		FROM %Table:VVP% VVP
		WHERE 	VVP.%notDel%   
			AND VVP.VVP_FILIAL 		= %xFilial:VVP%
			AND VVP.VVP_MODVEI 		= %Exp:_cModelo%
			AND VVP.VVP_SEGMOD 		= %Exp:_cSegmento%  
			AND VVP.VVP_FABMOD 		= %Exp:_cFabMod% 
			AND VVP.VVP_DATPRC 		= ( SELECT MAX(VVPB.VVP_DATPRC) 
										FROM %Table:VVP% VVPB 
										WHERE 	VVPB.%notDel%
		 							  		AND VVPB.VVP_FILIAL = %xFilial:VVP%
										  	AND VVPB.VVP_CODMAR = VVP.VVP_CODMAR 
										  	AND VVPB.VVP_MODVEI = VVP.VVP_MODVEI 
										  	AND VVPB.VVP_SEGMOD = VVP.VVP_SEGMOD 
										  	AND VVPB.VVP_FABMOD = VVP.VVP_FABMOD )
	EndSql      
	If (_cAliasPesq)->(Eof())
		U_ZRETMsgJson("veiculo","Veiculo nao encontrado !")
		Break 
	Endif 

	_nValTab := (_cAliasPesq)->VALTAB
	_nValIcm := (_cAliasPesq)->BASEST

   	_oJsonRet 					:= JsonObject():new()
	_oJsonRet["cdmodvei"]	  	:= _cModelo   
	_oJsonRet["cdsegmod"]	  	:= _cSegmento 
	_oJsonRet["anofabricacao"] 	:= _cAnoFab   
	_oJsonRet["anomodelo"]	 	:= _cAnoMod   
	_oJsonRet["valortabela"]  	:= _nValTab	  
	_oJsonRet["baseicms"]  		:= _nValIcm	  

	_lRet := .T.
End Sequence 
If !Empty(_cAliasPesq) .And. Select((_cAliasPesq)) <> 0
	(_cAliasPesq)->(DbCloseArea())
	Ferase(_cAliasPesq+GetDBExtension())
Endif 
Return _lRet

/*/{Protheus.doc} ZRESTValida
	Valida os dados redebidos do Json
	@author Victor Gisoldi Matos
	@since 18/09/2024
	@version 1.0
	@param 
	@type function
/*/
Static Function ZRESTValida( _oJson , _cModelo , _cSegmento , _cAnoFab, _cAnoMod )

Local _lRet As Logical

Default _cModelo	:= ""
Default _cSegmento	:= ""
Default _cAnoFab	:= ""
Default _cAnoMod	:= ""

Begin Sequence
	_lRet := .F.
	//Valida o código do modelo
	If Empty(_cModelo) .OR. len(_cModelo) > 30 .OR. !ZVldMod(_cModelo)
		U_ZRETMsgJson("cdmodvei","Código do modelo vazio, ou inválido: " + _cModelo )
		Break
 	Endif
	//Valida o segmento
	If Empty(_cSegmento) .OR. len(_cSegmento) > 15 .OR. !ZVldSeg(_cSegmento)
		U_ZRETMsgJson("cdsegmod","Código do Segmento vazio, ou inválido: " + _cSegmento )
		Break
 	Endif
	//Valida o Ano de Fabricacao
	If Empty(_cAnoFab) .OR. len(_cAnoFab) <> 4 .OR. !IsNumeric(_cAnoFab)
		U_ZRETMsgJson("anofabricacao","Ano de Fabricacao vazio, ou inválido: " + _cAnoFab )
		Break
 	Endif
	//Valida o Ano do Modelo
	If Empty(_cAnoMod) .OR. len(_cAnoMod) <> 4 .OR. !IsNumeric(_cAnoMod)
		U_ZRETMsgJson("anomodelo","Ano do Modelo vazio, ou inválido: " + _cAnoMod )
		Break
 	Endif
	_lRet := .T.
End Sequence 
Return _lRet


/*/{Protheus.doc} VldMod
Valida de o codigo de modelo recebido no Json é valido
@type  Function
@author Victor Matos
@since 30/09/2024
@version version
@param param_name, param_type, param_descr
@return return_var, return_type, return_description
@example
(examples)
@see (links_or_references)
/*/
Static Function ZVldMod(_cModelo)
Local _lRet			:= .F.				As Logical
Local _cAliasPesq	:= GetNextAlias() 	As Character

Default _cModelo 	:= ""

Begin Sequence 
	If Empty(_cModelo)
		Break 
	Endif	
	BeginSql Alias _cAliasPesq
		SELECT 	VV2.VV2_MODVEI 
		FROM 	%Table:VV2% VV2
		WHERE	VV2.%notDel%
			AND VV2.VV2_MODVEI		= %Exp:_cModelo%  
	EndSql      
	If (_cAliasPesq)->(Eof())
		Break 
	Endif 
	_lRet	:= .T.
End  Sequence 
If !Empty(_cAliasPesq) .And. Select((_cAliasPesq)) <> 0
	(_cAliasPesq)->(DbCloseArea())
	Ferase(_cAliasPesq+GetDBExtension())
Endif 
Return _lRet

/*/{Protheus.doc} VldSeg
Valida de o segmento recebido no json é válido
@type  Function
@author Victor Gisoldi Matos
@since 30/09/2024
@version version
@param param_name, param_type, param_descr
@return return_var, return_type, return_description
@example
(examples)
@see (links_or_references)
/*/
Static Function ZVldSeg(_cSegmento)
Local _lRet			:= .F.				As Logical
Local _cAliasPesq	:= GetNextAlias() 	As Character

Default _cSegmento 	:= ""

Begin Sequence 
	If Empty(_cSegmento)
		Break 
	Endif	
	BeginSql Alias _cAliasPesq
		SELECT 	VVX.VVX_SEGMOD 
		FROM 	%Table:VVX% VVX
		WHERE	VVX.%notDel%
			AND VVX.VVX_SEGMOD		= %Exp:_cSegmento%  
	EndSql      
	If (_cAliasPesq)->(Eof())
		Break 
	Endif 
	_lRet	:= .T.
End  Sequence 
If !Empty(_cAliasPesq) .And. Select((_cAliasPesq)) <> 0
	(_cAliasPesq)->(DbCloseArea())
	Ferase(_cAliasPesq+GetDBExtension())
Endif 
Return _lRet



/*/{Protheus.doc} ValidOJson
Valida os Itens do oJson
@author Victor Gisoldi Matos
@since 18/09/2024
@version 1.0
@param nCode, numeric, descricao
@param cMsg, characters, descricao
@type function
/*/
Static Function ValidOJson( _oJson , _cTipo )

Local _lRet		As Logical
Local _aMens 	As Array

//Tem a função de validar os itens obrigatórios neste caso o vabeçalho ZWSRFUN.PRW
_aMens	:= U_ZVLDOBRJ( _oJson , _aRetMsg , /*_lItem*/ , /*_lTodos*/ )
_lRet	:= .T.
If Len(_aMens) > 0
  	_aMsgRet 	:= _aMens
	_lRet		:= .F.	
Endif
Return _lRet


/*/{Protheus.doc} ZRETJson
//Retorna Numero do Erro 
@author Victor Gisoldi Matos
@since 01/10/2024
@version undefined
@param _aMsg, array, descrição
@type function
/*/
Static Function ZRETJson(_cRefMsg, _cMsgRet, _cVar)

Local _nRet := 999
Local _nPos

Default _cMsgRet := ""

Begin Sequence
	If Type("_aRetMsg") <> "A"
		Private _aRetMsg := {}
	EndIf
	If Type("_aMsgRet") <> "A"
		Private _aMsgRet := {}
	EndIf

  	_nPos := Ascan(_aRetMsg,{|x| x[2] == _cRefMsg})
	If _nPos > 0 
		_nRet := _aRetMsg[_nPos,1]
	EndIf	
	If Empty(_cMsgRet) .and. Len(_aRetMsg[_nPos]) >= 5 .and. ValType(_aRetMsg[_nPos,5]) == "C"
		_cMsgRet := _aRetMsg[_nPos,5]+" !"
	Endif	
	Aadd(_aMsgRet, {_nRet,_cMsgRet, _cVar})
End Sequence

Return _nRet

/*/{Protheus.doc} ZRESTVLRMsg
//Carrega Numero do Erro para retorno
@author Victor Gisoldi Matos
@since 18/09/2024
@version 1.0
@param _aMsg , array , descrição
@type function

Layout que será recebido da Autoware:
{
   "cdmodvei":"T17W5L4FP",
   "cdsegmod":"C755TRYBLP",
   "anofabricacao":"2024",
   "anomodelo":"2025"
}
/*/
Static Function ZRESTVLRMsg()
Local _aRet As Array
Begin Sequence
	_aRet := {}
	//			{ Nr Ret , Tags Json	   	, Item ,	Obrig ,	Descrição	
	Aadd(_aRet, { 100   , "ok"			   	, .F.  , .F.	  	, "Processo realizado com sucesso"	 } )

	Aadd(_aRet, { 300	, "empresa"	   		, .F.  , .F.   , "Empresa nao informada"				 } )
	Aadd(_aRet, { 301	, "filial"		   	, .F.  , .F.   	, "Filial nao informada"				 } )
	Aadd(_aRet, { 302	, "token"		   	, .F.  , .F.   	, "Token Invalido"					 } )
	Aadd(_aRet, { 303	, "ambiente"	   	, .F.  , .F.   	, "Nao foi possivel acessar ambiente"  } )
	Aadd(_aRet, { 304	, "responsavel"   	, .F.  , .F.   	, "Não Autorizado"					 } )

	Aadd(_aRet, { 400 	, "cdmodvei"	   	, .F.  , .T.   	, "Modelo do veículo com problemas"	 } )
	Aadd(_aRet, { 401 	, "cdsegmod"	   	, .F.  , .T.   	, "Segmento do veículo com problemas"  } )
	Aadd(_aRet, { 402 	, "anofabricacao" 	, .F.  , .T.   	, "Ano de Fabricacao com problemas"	 } )
	Aadd(_aRet, { 403 	, "anomodelo" 	   	, .F.  , .T.   	, "Ano de Fabricacao com problemas"	 } )

	Aadd(_aRet, { 500	,"conexao"			, .F.	, .T.	, "Problemas relativo a conexão"		})

	Aadd(_aRet, { 600	,"erropad"			, .F.	, .T.	, "Nao foi possivel atualizar Cliente"})

End Sequence

Return _aRet


